#include <iostream>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

// Lossy buffer class.  This is a class which buffers data 
// between producer and consumer threads. The buffer always holds the 
// latest data generated by the producer. There is no requirement that
// the consumer get every item generated. Instead, it just wants the 
// most recent data for each Read() call.
template <typename T>
class TSBuffer 
{
   T    buffer; // the buffer to share between threads
   bool valid;  // is this data valid - buffer has data not yet seen by reader

   public:
      TSBuffer(void)
      {
         valid = false;  // initial state is no valid data
      }
      ~TSBuffer()
      {
	 // Nothing interesting to do - destructor for T should
	 // handle all the cleanup
      }

      // Update buffer with most recently read data
      void Update(const T &data) 
      {
         buffer = data;
         valid  = true;
      }                       

      // Read most recently updated data
      void Read(T &data) 
      {
//	 while (!valid) { } 
         data  = buffer;   // copy data from buffer 
         valid = false;    // mark data as invalid - prevent repeat reads of same data
      }
};

// Create 2 threads that operate on a shared buffer.
// The producer (pro) thread generates data and adds it to the 
// buffer. For an example, this data is just 3 sequential numbers
// held in a std::vector<int>
// The consumer (con) thread reads the data and make sure that
// it fits the sequential pattern written by the producer.

// typedef the shared buffer type since typing std::vector<int> 
// all the time gets old
typedef std::vector<int> TSBuffer_Data;

// Prototypes for producer and consumer functions.  pthreads
// requires this function type - using void * to pass and return
// data makes the functions generic. void * could be a pointer to 
// a single variable or the start of an array.  The caller and 
// function just have to agree on what the data is and how it is stored.
void *producer(void *data);
void *consumer(void *data);

int main(int argc, char **argv) 
{
   // Thread ids for producer and consumer thread
   // pthread_t is an opaque type - that is, you don't
   // have to worry about what is in it, just pass it
   // as needed to various pthread_* functions and they'll
   // do the work for you.
   pthread_t pro, con;

   // Buffer shared by producer and consumer.  Since
   // threads have separate local variable, sharing a buffer like
   // this is a way to get them to communicate without using globals
   TSBuffer <TSBuffer_Data> tsBuffer;
   int rc;

   // Here we're creating a thread identified by the
   // pro variable. The thread will start running as if we made 
   // a normal call to producer(&tsBuffer), but it will be running
   // in parallel at the same time execution continues along in the 
   // main function.  
   //
   // pthread create takes 4 arguments
   // first is a pthread_t which IDs the thread
   // second is flags - NULL uses the defaults which is fine here
   // third is a function to start executing
   // fourth is a pointer to arguments to that function
   rc = pthread_create(&pro, NULL, producer, &tsBuffer);
   if (rc != 0)
   {
      perror("pthread_create for producer");
      return -1;
   }

   // Create another thread. This one consumes (reads) the 
   // data created in producer() above.
   pthread_create(&con, NULL, consumer, &tsBuffer);
   if (rc != 0)
   {
      perror("pthread_create for consumer");
      return -1;
   }

   // pthread_join waits for the given thread to finish
   // Without this call, main will continue on and exit immediately, 
   // which will shut down all of the newly created threads along with it 
   rc = pthread_join(pro, NULL);
   if (rc != 0)
   {
      perror("pthread_join for producer");
      return -1;
   }
   
   // don't join consumer since it doesn't know when to exit - 
   // it is just reading data until the program quits
   //pthread_join(con, NULL); 
}

void *producer(void *data)
{
   // Pointer casting magic to extract a pointer to the
   // shared buffer from the void *data parameter
   TSBuffer <TSBuffer_Data> *tsBuffer = (TSBuffer <TSBuffer_Data> *)data;

   // Holds dat going into the shared buffer
   TSBuffer_Data vec(3); 

   for (int i = 0; i < 10000000; i ++)
   {
      // Write sequential values to array
      vec[0] = i;
      vec[1] = i + 1;
      vec[2] = i + 2;
      // Set the buffer to that array
      tsBuffer->Update(vec);
      // Pause for a time - used to simulate the processing which 
      // might be needed to generate real data
      //usleep(1000);
   }
}

void *consumer(void *data)
{
   // Pointer casting magic to extract a pointer to the
   // shared buffer from the void *data parameter
   TSBuffer <TSBuffer_Data> *tsBuffer = (TSBuffer <TSBuffer_Data> *)data;

   // For data read out of the buffer
   TSBuffer_Data vec(3);

   while (1)
   {
      tsBuffer->Read(vec); // grab most recently written data

      // Make sure the data is sequential
      // It has to be, since that's what was written 
      // by the producer() function
      if ((vec[1] != (vec[0] + 1)) || (vec[2] != (vec[0] + 2)))
      {
	 std::cout << "Mismatch : " << vec[0] << " " << vec[1] << " " << vec[2] << std::endl;
	 exit(-1);
      }
      //usleep(2000);
   }
}

