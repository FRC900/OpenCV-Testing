#ifndef THREADSAFE_QUEUE_INC__
#define THREADSAFE_QUEUE_INC__
#include <queue>
#include <pthread.h>
#include <unistd.h>

// Thread-safe lossy queue class.  This is a class which queues data 
// between producer and consumer threads. The queue always holds the 
// latest data generated by the producer. There is no requirement that
// the consumer get every item generated. Instead, it just wants the 
// most recent data for each Read() call.
template <typename T>
class TSQueue 
{
   // Mutex (mutual-exclusion) is a variable used to control access to
   // shared data. A lock() call on a mutex will only allow one caller through
   // at once. Any subsequent call to lock() by another thread before the
   // first code in calls unlock() will wait.  Once unlock() is called, another
   // thread will be allowed through. This guarantees that only one 
   // thread is operating on the shared data at a given time.
   pthread_mutex_t mutex;
   
   // Conditions to wait on when queue is empty / full
   pthread_cond_t  queue_empty;

   std::queue<T>   queue; // the queue to share between threads

   public:
      TSQueue(void)
      {
         pthread_mutex_init(&mutex, NULL);
         pthread_cond_init(&cond_empty, NULL);
      }
      ~TSQueue()
      {
         pthread_mutex_destroy(&mutex);
         pthread_cond_destroy(&cond_empty);
      }

      // Update queue with most recently read data
      void Enquque(const T &data) 
      {
         pthread_mutex_lock(&mutex);

	 queue.push(data);

         pthread_cond_signal(&cond_empty);  // wake up reader if it is waiting for valid data
         pthread_mutex_unlock(&mutex);      // release the queue, allow another thread into
      }                                     // the critical sections of code

      void Dequeue(T &data) 
      {
         pthread_mutex_lock(&mutex);      
         while (queue.empty())                    
           pthread_cond_wait(&cond_empty, &mutex);

	 data = queue.front();
	 queue.pop();
         pthread_mutex_unlock(&mutex);          // release the lock() so other code can acquire it
      }
};

#endif

